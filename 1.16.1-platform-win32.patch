--- origsrc/glom-1.16.1/configure.ac	2010-10-19 06:07:54.000000000 -0500
+++ src/glom-1.16.1/configure.ac	2010-12-29 21:56:59.107472600 -0600
@@ -69,7 +69,11 @@ AM_GLIB_GNU_GETTEXT
 AC_DEFINE([GETTEXT_PACKAGE], [PACKAGE_TARNAME], [Define to the gettext package name.])
 
 AC_MSG_CHECKING([whether to enable Windows specific options])
-AS_CASE([$host_os], [mingw*], [glom_host_win32=yes], [glom_host_win32=no])
+glom_host_cygwin=no
+glom_host_win32=no
+AS_CASE([$host_os], [mingw*], [glom_host_win32=yes],
+                    [cygwin*], [glom_host_cygwin=yes],
+                    [])
 AC_MSG_RESULT([$glom_host_win32])
 
 AS_IF([test "x$glom_host_win32" = xyes],
@@ -147,7 +151,7 @@ AC_ARG_ENABLE([maemo-launcher],
 # libgda >= 4.1.2 is also OK, but not 4.1.<2.
 REQUIRED_LIBGLOM_LIBS='gthread-2.0 giomm-2.4 libxml++-2.6 >= 2.23.1 pygda-4.0 >= 2.25.3 pygobject-2.0 >= 2.6.0 libgdamm-4.0 >= 3.99.21 libgda-4.0 >= 4.0.4 libgda-postgres-4.0'
 
-AS_IF([test "x$glom_host_win32" != xyes],
+AS_IF([test "x$glom_host_win32" != xyes && test "x$glom_host_cygwin" != xyes],
       [REQUIRED_LIBGLOM_LIBS="$REQUIRED_LIBGLOM_LIBS libepc-1.0 >= 0.3.1"])
 
 # Libraries used by Glom:
--- origsrc/glom-1.16.1/glom/application.cc	2010-08-31 04:33:14.000000000 -0500
+++ src/glom-1.16.1/glom/application.cc	2010-12-29 21:56:59.107472600 -0600
@@ -51,10 +51,10 @@
 #include <hildon-fmmm.h>
 #endif // GLOM_ENABLE_MAEMO
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 #include <libepc/consumer.h>
 #include <libsoup/soup-status.h>
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 //#include <gtk/gtk.h>
 
@@ -105,7 +105,7 @@ Application::Application(BaseObjectType*
   add_mime_type("application/x-glom"); //TODO: make this actually work - we need to register it properly.
 
 #ifndef GLOM_ENABLE_CLIENT_ONLY
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   //Install UI hooks for this:
   ConnectionPool* connection_pool = ConnectionPool::get_instance();
   if(!connection_pool)
@@ -745,7 +745,7 @@ void Application::ui_warning_load_failed
 }
 
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 void Application::open_browsed_document(const EpcServiceInfo* server, const Glib::ustring& service_name)
 {
   gsize length = 0;
@@ -872,7 +872,7 @@ void Application::open_browsed_document(
     }
   }
 }
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 #ifndef GLOM_ENABLE_CLIENT_ONLY
 //Copied from bakery:
@@ -1491,7 +1491,7 @@ bool Application::offer_new_or_existing(
       case Dialog_ExistingOrNew::OPEN_URI:
         open_document(dialog->get_uri());
         break;
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       case Dialog_ExistingOrNew::OPEN_REMOTE:
         open_browsed_document(dialog->get_service_info(), dialog->get_service_name());
         break;
--- origsrc/glom-1.16.1/glom/application.h	2010-08-31 04:26:08.000000000 -0500
+++ src/glom-1.16.1/glom/application.h	2010-12-29 21:56:59.123072600 -0600
@@ -199,13 +199,13 @@ private:
   void on_connection_avahi_done();
 #endif // !GLOM_ENABLE_CLIENT_ONLY
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   /** Offer a file chooser dialog, with a Browse Network button.
    * @param browsed This will be set to true if the user chose a networked glom instance to open.
    * @browsed_server This will be filled with the server details if browsed was set to true.
    */
   Glib::ustring ui_file_select_open_with_browse(bool& browsed, EpcServiceInfo*& browsed_server, Glib::ustring& browsed_service_name, const Glib::ustring& starting_folder_uri = Glib::ustring());
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   virtual void document_history_add(const Glib::ustring& file_uri); //overridden.
 
@@ -215,9 +215,9 @@ private:
   void on_connection_save_backup_progress();
   void on_connection_convert_backup_progress();
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   void open_browsed_document(const EpcServiceInfo* server, const Glib::ustring& service_name);
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   static Glib::ustring get_file_uri_without_extension(const Glib::ustring& uri);
 
--- origsrc/glom-1.16.1/glom/dialog_existing_or_new.cc	2010-10-19 05:58:27.000000000 -0500
+++ src/glom-1.16.1/glom/dialog_existing_or_new.cc	2010-12-29 21:56:59.123072600 -0600
@@ -36,7 +36,8 @@
 
 #ifdef G_OS_WIN32
 # include <glib/gwin32.h>
-#else
+#endif
+#ifndef G_PLATFORM_WIN32
 # include <libepc/service-type.h>
 #endif
 
@@ -133,7 +134,7 @@ Dialog_ExistingOrNew::Dialog_ExistingOrN
   m_iter_existing_other = m_existing_model->append();
   (*m_iter_existing_other)[m_existing_columns.m_col_title] = _("Select File");
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   m_iter_existing_network = m_existing_model->append();
   (*m_iter_existing_network)[m_existing_columns.m_col_title] = _("Local Network");
 #endif
@@ -178,7 +179,7 @@ Dialog_ExistingOrNew::Dialog_ExistingOrN
 
 
   // Browse local network
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   gchar* service_type = epc_service_type_new(EPC_PROTOCOL_HTTPS, "glom");
   m_service_monitor = epc_service_monitor_new_for_types(0, service_type, (void*)0);
   g_signal_connect(m_service_monitor, "service-found", G_CALLBACK(on_service_found_static), this);
@@ -204,7 +205,7 @@ Dialog_ExistingOrNew::Dialog_ExistingOrN
   if(children.begin() == children.end())
     m_iter_existing_recent_dummy = create_dummy_item_existing(m_iter_existing_recent, _(RECENT_DUMMY_TEXT));
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   // Will be removed when items are added:
   m_iter_existing_network_dummy = create_dummy_item_existing(m_iter_existing_network, _(NETWORK_DUMMY_TEXT));
 #endif
@@ -213,7 +214,7 @@ Dialog_ExistingOrNew::Dialog_ExistingOrN
   // Expand recently used files and the networked files,
   // because the contents help to explain what this is: 
   m_existing_view->expand_row(m_existing_model->get_path(m_iter_existing_recent), false);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   m_existing_view->expand_row(m_existing_model->get_path(m_iter_existing_network), false);
 #endif
 
@@ -292,7 +293,7 @@ bool Dialog_ExistingOrNew::list_examples
 
 Dialog_ExistingOrNew::~Dialog_ExistingOrNew()
 {
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   if(m_service_monitor)
   {
     g_object_unref(m_service_monitor);
@@ -313,7 +314,7 @@ Dialog_ExistingOrNew::~Dialog_ExistingOr
 bool Dialog_ExistingOrNew::on_existing_select_func(const Glib::RefPtr<Gtk::TreeModel>& model, const Gtk::TreeModel::Path& path, bool /* path_currently_selected */)
 {
   Gtk::TreeModel::iterator iter = model->get_iter(path);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   if(iter == m_iter_existing_network)
     return false; /* Do not allow parent nodes to be selected. */
 #endif
@@ -344,7 +345,7 @@ Dialog_ExistingOrNew::Action Dialog_Exis
     iter = m_existing_view->get_selection()->get_selected();
     if(m_existing_model->is_ancestor(m_iter_existing_recent, iter))
       return OPEN_URI;
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     if(m_existing_model->is_ancestor(m_iter_existing_network, iter))
       return OPEN_REMOTE;
 #endif
@@ -412,7 +413,7 @@ Glib::ustring Dialog_ExistingOrNew::get_
   return Glib::ustring();
 }
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 EpcServiceInfo* Dialog_ExistingOrNew::get_service_info() const
 {
   Gtk::TreeModel::iterator iter;
@@ -477,7 +478,7 @@ void Dialog_ExistingOrNew::existing_icon
 
   if(iter == m_iter_existing_recent)
     pixbuf_renderer->property_stock_id() = Gtk::Stock::INDEX.id; // TODO: More meaningful icon?
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   else if(iter == m_iter_existing_network)
     pixbuf_renderer->property_stock_id() = Gtk::Stock::NETWORK.id;
 #endif
@@ -485,7 +486,7 @@ void Dialog_ExistingOrNew::existing_icon
     pixbuf_renderer->property_stock_id() = Gtk::Stock::OPEN.id;
   else if(m_iter_existing_recent_dummy.get() && iter == *m_iter_existing_recent_dummy)
     pixbuf_renderer->property_stock_id() = ""; // TODO: Use Stock::STOP instead?
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   else if(m_iter_existing_network_dummy.get() && iter == *m_iter_existing_network_dummy)
     pixbuf_renderer->property_stock_id() = ""; // TODO: Use Stock::STOP instead?
 #endif
@@ -498,7 +499,7 @@ void Dialog_ExistingOrNew::existing_icon
 
   if(iter == m_iter_existing_recent)
     pixbuf_renderer->set_property("stock-id", Gtk::StockID(Gtk::Stock::INDEX));
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   else if(iter == m_iter_existing_network)
     pixbuf_renderer->set_property("stock-id", Gtk::StockID(Gtk::Stock::NETWORK));
 #endif
@@ -506,7 +507,7 @@ void Dialog_ExistingOrNew::existing_icon
     pixbuf_renderer->set_property("stock-id", Gtk::StockID(Gtk::Stock::OPEN));
   else if(m_iter_existing_recent_dummy.get() && iter == *m_iter_existing_recent_dummy)
     pixbuf_renderer->set_property("stock-id", std::string()); // TODO: Use Stock::STOP instead?
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   else if(m_iter_existing_network_dummy.get() && iter == *m_iter_existing_network_dummy)
     pixbuf_renderer->set_property("stock-id", std::string()); // TODO: Use Stock::STOP instead?
 #endif
@@ -520,7 +521,7 @@ void Dialog_ExistingOrNew::existing_icon
       //pixbuf_renderer->property_pixbuf() = (*info)->get_icon(Gtk::ICON_SIZE_BUTTON);
       pixbuf_renderer->set_property("icon-name", Glib::ustring("glom"));
     }
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     else if(m_existing_model->is_ancestor(m_iter_existing_network, iter))
     {
       //pixbuf_renderer->property_stock_id() = Gtk::Stock::CONNECT.id;
@@ -553,7 +554,7 @@ void Dialog_ExistingOrNew::existing_titl
   text_renderer->property_foreground_set() = false;
   
   // Use grey if parent item has no children:
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   if( (iter == m_iter_existing_network && m_iter_existing_network_dummy.get()) ||
       (iter == m_iter_existing_recent && m_iter_existing_recent_dummy.get()))
 #else
@@ -568,7 +569,7 @@ void Dialog_ExistingOrNew::existing_titl
   // Default: Use default color
   text_renderer->set_property("foreground-set", false);
   // Use grey if parent item has no children
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   if( (iter == m_iter_existing_network && m_iter_existing_network_dummy.get()) ||
       (iter == m_iter_existing_recent && m_iter_existing_recent_dummy.get()))
 #else
@@ -710,12 +711,12 @@ void Dialog_ExistingOrNew::update_ui_sen
     {
       Gtk::TreeModel::iterator sel = m_existing_view->get_selection()->get_selected();
       sensitivity = (sel != m_iter_existing_recent);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       sensitivity = sensitivity && (sel != m_iter_existing_network);
 #endif
 
       sensitivity = sensitivity && (!m_iter_existing_recent_dummy.get() || sel != *m_iter_existing_recent_dummy);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       sensitivity = sensitivity && (!m_iter_existing_network_dummy.get() || sel != *m_iter_existing_network_dummy);
 #endif
     }
@@ -867,7 +868,7 @@ void Dialog_ExistingOrNew::on_stream_rea
 }
 #endif /* !GLOM_ENABLE_CLIENT_ONLY */
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 void Dialog_ExistingOrNew::on_service_found_static(EpcServiceMonitor* /* monitor */, gchar* name, EpcServiceInfo* info, gpointer user_data)
 {
   static_cast<Dialog_ExistingOrNew*>(user_data)->on_service_found(name, info);
@@ -919,7 +920,7 @@ void Dialog_ExistingOrNew::on_service_re
     }
   }
 }
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 void Dialog_ExistingOrNew::on_existing_row_activated(const Gtk::TreeModel::Path& /* path */, Gtk::TreeViewColumn* /* column */)
 {
--- origsrc/glom-1.16.1/glom/dialog_existing_or_new.h	2010-10-19 05:58:27.000000000 -0500
+++ src/glom-1.16.1/glom/dialog_existing_or_new.h	2010-12-29 21:56:59.138672600 -0600
@@ -35,7 +35,7 @@
 #include <gtkmm/notebook.h>
 #include <gtkmm/builder.h>
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 # include <libepc/service-monitor.h>
 #endif
 
@@ -62,7 +62,7 @@ public:
 
   Action get_action() const;
   Glib::ustring get_uri() const; // Only when get_action is NEW_FROM_TEMPLATE or OPEN_URI
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   EpcServiceInfo* get_service_info() const; // Only when get_action is OPEN_REMOTE
   Glib::ustring get_service_name() const; // Only when get_action is OPEN_REMOTE
 #endif
@@ -101,7 +101,7 @@ private:
   void on_stream_read(const Glib::RefPtr<Gio::AsyncResult>& res);
 #endif /* !GLOM_ENABLE_CLIENT_ONLY */
     
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   static void on_service_found_static(EpcServiceMonitor* monitor, gchar* name, EpcServiceInfo* info, gpointer user_data);
   static void on_service_removed_static(EpcServiceMonitor* monitor, gchar* name, gchar* type, gpointer user_data);
 
@@ -126,7 +126,7 @@ private:
       add(m_col_title);
       add(m_col_time);
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       add(m_col_service_name);
       add(m_col_service_info);
 #endif
@@ -137,7 +137,7 @@ private:
     Gtk::TreeModelColumn<Glib::ustring> m_col_title;
     Gtk::TreeModelColumn<std::time_t> m_col_time; // Sort criteria
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     // For service discovery:
     Gtk::TreeModelColumn<Glib::ustring> m_col_service_name;
     Gtk::TreeModelColumn<EpcServiceInfo*> m_col_service_info;
@@ -184,13 +184,13 @@ private:
 
   //Iterators to the parent nodes:
   Gtk::TreeModel::iterator m_iter_existing_recent;
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   Gtk::TreeModel::iterator m_iter_existing_network;
 #endif
   Gtk::TreeModel::iterator m_iter_existing_other;
  
   // Dummy children to indicate that a parent item has no (real) children
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   std::auto_ptr<Gtk::TreeModel::iterator> m_iter_existing_network_dummy;
 #endif
   std::auto_ptr<Gtk::TreeModel::iterator> m_iter_existing_recent_dummy;
@@ -206,7 +206,7 @@ private:
   std::auto_ptr<buffer> m_current_buffer;
 #endif /* !GLOM_ENABLE_CLIENT_ONLY */
     
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   EpcServiceMonitor* m_service_monitor;
 #endif
 
--- origsrc/glom-1.16.1/glom/frame_glom.cc	2010-08-31 04:33:14.000000000 -0500
+++ src/glom-1.16.1/glom/frame_glom.cc	2010-12-29 21:56:59.138672600 -0600
@@ -1197,7 +1197,7 @@ void Frame_Glom::on_menu_Mode_Toggle()
     m_Notebook_Find.set_current_view(list_or_details);
   }
 
-  #ifdef GLOM_ENABLE_CLIENT_ONLY
+  #ifdef GLOM_ENABLE_MAEMO
   Gtk::Window* parent = get_app_window();
   g_assert(parent);
   if(parent)
--- origsrc/glom-1.16.1/glom/libglom/connectionpool.cc	2010-10-19 05:58:27.000000000 -0500
+++ src/glom-1.16.1/glom/libglom/connectionpool.cc	2010-12-29 21:56:59.154272600 -0600
@@ -31,7 +31,8 @@
 
 #ifdef G_OS_WIN32
 # include <windows.h>
-#else
+#endif
+#ifndef G_PLATFORM_WIN32
 # include <libepc/shell.h> //For epc_shell_set_progress_hooks().
 # include <libepc/publisher.h>
 #endif
@@ -43,7 +44,7 @@
 #include <iostream>
 
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 static EpcProtocol publish_protocol = EPC_PROTOCOL_HTTPS;
 #endif
 
@@ -359,7 +360,7 @@ sharedptr<SharedConnection> ConnectionPo
         if(!m_pFieldTypes)
           m_pFieldTypes = new FieldTypes(m_refGdaConnection);
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
         //Let other clients discover this server via avahi:
         //TODO: Only advertize if we are the first to open the document,
         //to avoid duplicates.
@@ -368,7 +369,7 @@ sharedptr<SharedConnection> ConnectionPo
         Document* document = get_document();
         if(document && document->get_network_shared())
           avahi_start_publishing(); //Stopped in the signal_finished handler.
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 #ifdef GLIBMM_EXCEPTIONS_ENABLED
         return connect(); //Call this method recursively. This time m_refGdaConnection exists.
@@ -546,7 +547,7 @@ void ConnectionPool::on_sharedconnection
 
     m_refGdaConnection.reset();
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     //TODO: this should only even be started if we are the first to open the .glom file:
     avahi_stop_publishing();
 #endif
@@ -634,10 +635,10 @@ ConnectionPool::StartupErrors Connection
   if(started != Backend::STARTUPERROR_NONE)
     return started;
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   //Let clients discover this server via avahi:
   //avahi_start_publishing();
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   //If we crash while running (unlikely, hopefully), then try to cleanup.
   //Comment this out if you want to see the backtrace in a debugger.
@@ -666,10 +667,10 @@ bool ConnectionPool::cleanup(const SlotP
   invalidate_connection();
 
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   /* Stop advertising the self-hosting database server via avahi: */
   //avahi_stop_publishing();
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   //We don't need the segfault handler anymore:
   signal(SIGSEGV, previous_sig_handler);
@@ -837,7 +838,7 @@ Document* ConnectionPool::get_document()
   return m_slot_get_document();
 }
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 //static
 EpcContents* ConnectionPool::on_publisher_document_requested(EpcPublisher* /* publisher */, const gchar* /* key */, gpointer user_data)
 {
@@ -993,13 +994,13 @@ void ConnectionPool::avahi_stop_publishi
   std::cout << "debug: ConnectionPool::avahi_stop_publishing" << std::endl;
 #endif
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   epc_publisher_quit(m_epc_publisher);
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
   g_object_unref(m_epc_publisher);
   m_epc_publisher = 0;
 }
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 void ConnectionPool::set_get_document_func(const SlotGetDocument& slot)
 {
--- origsrc/glom-1.16.1/glom/libglom/connectionpool.h	2010-08-31 04:33:14.000000000 -0500
+++ src/glom-1.16.1/glom/libglom/connectionpool.h	2010-12-29 21:57:54.362768900 -0600
@@ -109,7 +109,7 @@ public:
 
   typedef sigc::slot<void> type_void_slot;
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   /** Set callbacks that will be called to show UI while starting to advertise
    * on the network via Avahi.
    *
@@ -267,14 +267,14 @@ public:
   typedef sigc::slot<Document*> SlotGetDocument;
   void set_get_document_func(const SlotGetDocument& slot);
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   static EpcContents* on_publisher_document_requested (EpcPublisher* publisher, const gchar* key, gpointer user_data);
   static gboolean on_publisher_document_authentication(EpcAuthContext* context, const gchar* user_name, gpointer user_data);
 
   static void on_epc_progress_begin(const gchar *title, gpointer user_data);
   static void on_epc_progress_update(gdouble progress, const gchar* message, gpointer user_data);
   static void on_epc_progress_end(gpointer user_data);
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   //TODO: Document
   void set_show_debug_output(bool val);
@@ -298,12 +298,12 @@ private:
 
   Document* get_document();
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   /** Advertize self-hosting via avahi:
    */
   void avahi_start_publishing();
   void avahi_stop_publishing();
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 private:
 
--- origsrc/glom-1.16.1/glom/main.cc	2010-09-17 07:51:45.000000000 -0500
+++ src/glom-1.16.1/glom/main.cc	2010-12-29 21:59:32.453739100 -0600
@@ -371,18 +371,18 @@ bool check_pygda_is_available_with_warni
 
 } //namespace Glom
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 extern "C" void __libc_freeres(void);
 #endif
 
 int
 main(int argc, char* argv[])
 {
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   //Force some cleanup at exit,
   //to help valgrind to detect memory leaks:
   atexit(__libc_freeres);
-#else
+#elif defined(G_OS_WIN32)
   WSADATA data;
   int errcode = WSAStartup(MAKEWORD(2, 0), &data);
   if(errcode != 0)
--- origsrc/glom-1.16.1/tests/test_python_module.cc	2010-08-31 04:26:08.000000000 -0500
+++ src/glom-1.16.1/tests/test_python_module.cc	2010-12-29 21:56:59.169872700 -0600
@@ -5,7 +5,7 @@
 #include "config.h"
 #include "glom/python_embed/glom_python.h"
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 extern "C" void __libc_freeres(void);
 #endif
 
@@ -41,7 +41,7 @@ bool gda_python_module_is_available()
 
 int main ()
 {
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   atexit(__libc_freeres);
 #endif
   Glom::libglom_init();  // Calls PyInitialize()
