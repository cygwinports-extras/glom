--- origsrc/glom-1.8.3/configure.in	2008-11-29 06:35:35.000000000 -0600
+++ src/glom-1.8.3/configure.in	2008-12-17 13:19:56.915750000 -0600
@@ -96,7 +96,7 @@
 	REQUIRED_LIBS="$REQUIRED_LIBS hildonmm libepc-1.0 >= 0.3.1 avahi-ui";
 elif test "$win32" = "true"; then
 	REQUIRED_LIBS="$REQUIRED_LIBS gtkmm-2.4 >= 2.10";
-else
+elif test "$enable_client_only" = "no"; then
 	REQUIRED_LIBS="$REQUIRED_LIBS iso-codes libepc-1.0 >= 0.3.1 avahi-ui";
 fi
 
--- origsrc/glom-1.8.3/glom/application.cc	2008-11-29 05:10:46.000000000 -0600
+++ src/glom-1.8.3/glom/application.cc	2008-12-17 13:15:06.337625000 -0600
@@ -44,11 +44,11 @@
 #include <hildon/hildon-window.h>
 #endif // GLOM_ENABLE_MAEMO
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 #include <libepc/consumer.h>
 #include <libsoup/soup-status.h>
 #include <avahi-ui/avahi-ui.h>
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 #include <gtk/gtkstock.h> /* For use with the avahi-ui dialog. */
 
@@ -610,7 +610,7 @@
   return true;
 }
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 void App_Glom::open_browsed_document(const EpcServiceInfo* server, const Glib::ustring& service_name)
 {
   gsize length = 0;
@@ -727,7 +727,7 @@
     }
   }
 }
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 //We override this so we can show the custom FileChooserDialog with the Browse Network button:
 void App_Glom::on_menu_file_open()
@@ -739,22 +739,22 @@
 
   //Ask user to choose file to open:
   bool browsed = false;
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   EpcServiceInfo* browsed_server = 0;
   Glib::ustring browsed_service_name;
   Glib::ustring file_uri = ui_file_select_open_with_browse(browsed, browsed_server, browsed_service_name);
 #else
   Glib::ustring file_uri = ui_file_select_open();
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
   if(!file_uri.empty() && !browsed)
     open_document(file_uri);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   else if(browsed)
     open_browsed_document(browsed_server, browsed_service_name);
 
  if(browsed_server)
     epc_service_info_unref(browsed_server);
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 }
 
 void App_Glom::on_menu_file_close() //override
@@ -1213,7 +1213,7 @@
         open_document(dialog->get_uri());
         break;
 #endif // !GLOM_ENABLE_CLIENT_ONLY
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       case Dialog_ExistingOrNew::OPEN_REMOTE:
         open_browsed_document(dialog->get_service_info(), dialog->get_service_name());
         break;
@@ -1980,7 +1980,7 @@
 }
 #endif // !GLOM_ENABLE_CLIENT_ONLY
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 //This is replaced (not overridden) so we can use our custom FileChooserDialog:
 Glib::ustring App_Glom::ui_file_select_open_with_browse(bool& browsed, EpcServiceInfo*& browsed_server, Glib::ustring& browsed_service_name, const Glib::ustring& starting_folder_uri)
 {
@@ -2057,7 +2057,7 @@
 
   return Glib::ustring();
 }
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 #ifndef GLOM_ENABLE_CLIENT_ONLY
 Glib::ustring App_Glom::ui_file_select_save(const Glib::ustring& old_file_uri) //override
--- origsrc/glom-1.8.3/glom/dialog_existing_or_new.cc	2008-10-23 14:42:34.000000000 -0500
+++ src/glom-1.8.3/glom/dialog_existing_or_new.cc	2008-12-17 17:19:40.868875000 -0600
@@ -32,8 +32,10 @@
 #ifdef G_OS_WIN32
 # include <glib/gwin32.h>
 #else
+#ifndef G_PLATFORM_WIN32
 # include <libepc/service-type.h>
 #endif
+#endif
 
 #include <iostream>
 
@@ -143,7 +145,7 @@
   m_iter_existing_other = m_existing_model->append();
   (*m_iter_existing_other)[m_existing_columns.m_col_title] = _("Select File");
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   m_iter_existing_network = m_existing_model->append();
   (*m_iter_existing_network)[m_existing_columns.m_col_title] = _("Local Network");
 #endif
@@ -187,7 +189,7 @@
 #endif /* !GLOM_ENABLE_CLIENT_ONLY */
 
   // Browse local network
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   gchar* service_type = epc_service_type_new(EPC_PROTOCOL_HTTPS, "glom");
   m_service_monitor = epc_service_monitor_new_for_types(NULL, service_type, NULL);
   g_signal_connect(m_service_monitor, "service-found", G_CALLBACK(on_service_found_static), this);
@@ -213,7 +215,7 @@
   if(children.begin() == children.end())
     m_iter_existing_recent_dummy = create_dummy_item_existing(m_iter_existing_recent, _(RECENT_DUMMY_TEXT));
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   // Will be removed when items are added:
   m_iter_existing_network_dummy = create_dummy_item_existing(m_iter_existing_network, _(NETWORK_DUMMY_TEXT));
 #endif
@@ -248,7 +250,7 @@
 
 Dialog_ExistingOrNew::~Dialog_ExistingOrNew()
 {
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   if(m_service_monitor)
   {
     g_object_unref(m_service_monitor);
@@ -280,7 +282,7 @@
 bool Dialog_ExistingOrNew::on_existing_select_func(const Glib::RefPtr<Gtk::TreeModel>& model, const Gtk::TreeModel::Path& path, bool path_currently_selected)
 {
   Gtk::TreeModel::iterator iter = model->get_iter(path);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   if(iter == m_iter_existing_network)
     return false; /* Do not allow parent nodes to be selected. */
 #endif
@@ -310,7 +312,7 @@
     iter = m_existing_view->get_selection()->get_selected();
     if(m_existing_model->is_ancestor(m_iter_existing_recent, iter))
       return OPEN_URI;
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     if(m_existing_model->is_ancestor(m_iter_existing_network, iter))
       return OPEN_REMOTE;
 #endif
@@ -367,7 +369,7 @@
   }
 }
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 EpcServiceInfo* Dialog_ExistingOrNew::get_service_info() const
 {
   Gtk::TreeModel::iterator iter;
@@ -416,7 +418,7 @@
 
   if(iter == m_iter_existing_recent)
     pixbuf_renderer->property_stock_id() = Gtk::Stock::INDEX.id; // TODO: More meaningful icon?
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   else if(iter == m_iter_existing_network)
     pixbuf_renderer->property_stock_id() = Gtk::Stock::NETWORK.id;
 #endif
@@ -424,7 +426,7 @@
     pixbuf_renderer->property_stock_id() = Gtk::Stock::OPEN.id;
   else if(m_iter_existing_recent_dummy.get() != NULL && iter == *m_iter_existing_recent_dummy)
     pixbuf_renderer->property_stock_id() = Gtk::Stock::DIALOG_ERROR.id; // TODO: Use Stock::STOP instead?
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   else if(m_iter_existing_network_dummy.get() != NULL && iter == *m_iter_existing_network_dummy)
     pixbuf_renderer->property_stock_id() = Gtk::Stock::DIALOG_ERROR.id; // TODO: Use Stock::STOP instead?
 #endif
@@ -436,7 +438,7 @@
       //pixbuf_renderer->property_pixbuf() = (*info)->get_icon(Gtk::ICON_SIZE_BUTTON);
       pixbuf_renderer->set_property("icon-name", Glib::ustring("glom"));
     }
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     else if(m_existing_model->is_ancestor(m_iter_existing_network, iter))
     {
       //pixbuf_renderer->property_stock_id() = Gtk::Stock::CONNECT.id;
@@ -460,7 +462,7 @@
   // Default: Use default color
   text_renderer->property_foreground_set() = false;
   // Use grey if parent item has no children
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   if( (iter == m_iter_existing_network && m_iter_existing_network_dummy.get()) ||
       (iter == m_iter_existing_recent && m_iter_existing_recent_dummy.get()))
 #else
@@ -546,12 +548,12 @@
     {
       Gtk::TreeModel::iterator sel = m_existing_view->get_selection()->get_selected();
       sensitivity = (sel != m_iter_existing_recent);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       sensitivity = sensitivity && (sel != m_iter_existing_network);
 #endif
 
       sensitivity = sensitivity && (!m_iter_existing_recent_dummy.get() || sel != *m_iter_existing_recent_dummy);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       sensitivity = sensitivity && (!m_iter_existing_network_dummy.get() || sel != *m_iter_existing_network_dummy);
 #endif
     }
@@ -698,7 +700,7 @@
 }
 #endif /* !GLOM_ENABLE_CLIENT_ONLY */
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 void Dialog_ExistingOrNew::on_service_found(const Glib::ustring& name, EpcServiceInfo* info)
 {
   //Translator hint: This is <Service Name> on <Host> (via Network Interface such as eth0).
@@ -740,7 +742,7 @@
     }
   }
 }
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 void Dialog_ExistingOrNew::on_existing_row_activated(const Gtk::TreeModel::Path& path, Gtk::TreeViewColumn* column)
 {
--- origsrc/glom-1.8.3/glom/dialog_existing_or_new.h	2008-10-23 14:42:34.000000000 -0500
+++ src/glom-1.8.3/glom/dialog_existing_or_new.h	2008-12-17 17:21:46.165750000 -0600
@@ -34,7 +34,7 @@
 #include <gtkmm/notebook.h>
 #include <libglademm/xml.h>
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 # include <libepc/service-monitor.h>
 #endif
 
@@ -58,7 +58,7 @@
 
   Action get_action() const;
   Glib::ustring get_uri() const; // Only when get_action is NEW_FROM_TEMPLATE or OPEN_URI
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   EpcServiceInfo* get_service_info() const; // Only when get_action is OPEN_REMOTE
   Glib::ustring get_service_name() const; // Only when get_action is OPEN_REMOTE
 #endif
@@ -90,7 +90,7 @@
   void on_stream_read(const Glib::RefPtr<Gio::AsyncResult>& res);
 #endif /* !GLOM_ENABLE_CLIENT_ONLY */
     
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   static void on_service_found_static(EpcServiceMonitor* monitor, gchar* name, EpcServiceInfo* info, gpointer user_data) { static_cast<Dialog_ExistingOrNew*>(user_data)->on_service_found(name, info); }
   static void on_service_removed_static(EpcServiceMonitor* monitor, gchar* name, gchar* type, gpointer user_data) { static_cast<Dialog_ExistingOrNew*>(user_data)->on_service_removed(name, type); }
 
@@ -114,7 +114,7 @@
       add(m_col_title);
       add(m_col_time);
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       add(m_col_service_name);
       add(m_col_service_info);
 #endif
@@ -125,7 +125,7 @@
     Gtk::TreeModelColumn<Glib::ustring> m_col_title;
     Gtk::TreeModelColumn<std::time_t> m_col_time; // Sort criteria
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     // For service discovery:
     Gtk::TreeModelColumn<Glib::ustring> m_col_service_name;
     Gtk::TreeModelColumn<EpcServiceInfo*> m_col_service_info;
@@ -172,7 +172,7 @@
   Gtk::CellRendererText m_new_title_renderer;
 
   Gtk::TreeModel::iterator m_iter_existing_recent;
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   Gtk::TreeModel::iterator m_iter_existing_network;
 #endif
   Gtk::TreeModel::iterator m_iter_existing_other;
@@ -181,7 +181,7 @@
   Gtk::TreeModel::iterator m_iter_new_template;
 
   // Dummy children to indicate that a parent item has no (real) children
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   std::auto_ptr<Gtk::TreeModel::iterator> m_iter_existing_network_dummy;
 #endif
   std::auto_ptr<Gtk::TreeModel::iterator> m_iter_existing_recent_dummy;
@@ -197,7 +197,7 @@
   std::auto_ptr<buffer> m_current_buffer;
 #endif /* !GLOM_ENABLE_CLIENT_ONLY */
     
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   EpcServiceMonitor* m_service_monitor;
 #endif
 
--- origsrc/glom-1.8.3/glom/libglom/connectionpool.cc	2008-11-29 05:10:42.000000000 -0600
+++ src/glom-1.8.3/glom/libglom/connectionpool.cc	2008-12-17 13:18:48.915750000 -0600
@@ -29,13 +29,13 @@
 #include <glom/libglom/utils.h>
 #include <libgdamm/connectionevent.h>
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 #include <libepc/shell.h> //For epc_shell_set_progress_hooks().
 #endif
 
 #include <glibmm/i18n.h>
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 #include <libepc/publisher.h>
 #endif
 
@@ -67,7 +67,7 @@
 
 /* TODO: Should this be used in client-only mode? */
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 static EpcProtocol publish_protocol = EPC_PROTOCOL_HTTPS;
 #endif
 
@@ -542,12 +542,12 @@
 #endif
               
 #ifndef GLOM_ENABLE_CLIENT_ONLY
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
            //Let other clients discover this server via avahi:
            //TODO: Only advertize if we are the first to open the document,
            //to avoid duplicates.
            avahi_start_publishing(); //Stopped in the signal_finished handler.
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 #endif // !GLOM_ENABLE_CLIENT_ONLY
 
 #ifdef GLIBMM_EXCEPTIONS_ENABLED
@@ -807,7 +807,7 @@
     m_refGdaConnection.clear();
 
 #ifndef GLOM_ENABLE_CLIENT_ONLY
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     //TODO: this should only even be started if we are the first to open the .glom file:
     avahi_stop_publishing();
 #endif
@@ -1016,10 +1016,10 @@
   m_self_hosting_active = true;
   set_try_other_ports(false); //Only try to connect to this known instance, instead of finding others.
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   //Let clients discover this server via avahi:
   avahi_start_publishing();
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   //If we crash while self-hosting (unlikely, hopefully) 
   //then try to stop the postgres instance instead of leaving it running as an orphan.
@@ -1033,10 +1033,10 @@
   if(!m_self_hosting_active)
     return; //Don't try to stop it if we have not started it.
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   /* Stop advertising the self-hosting database server via avahi: */
   avahi_stop_publishing();
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   const std::string dbdir_uri = m_self_hosting_data_uri;
   const std::string dbdir = Glib::filename_from_uri(dbdir_uri);
@@ -1686,13 +1686,13 @@
   std::cout << "debug: ConnectionPool::avahi_stop_publishing" << std::endl;
 #endif
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   epc_publisher_quit(m_epc_publisher);
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
   g_object_unref(m_epc_publisher);
   m_epc_publisher = NULL;
 }
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 void ConnectionPool::set_get_document_func(const SlotGetDocument& slot)
 {
--- origsrc/glom-1.8.3/glom/main.cc	2008-11-29 05:10:46.000000000 -0600
+++ src/glom-1.8.3/glom/main.cc	2008-12-17 17:41:40.353250000 -0600
@@ -92,18 +92,18 @@
 
 } //namespace Glom
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 extern "C" void __libc_freeres(void);
 #endif
 
 int 
 main(int argc, char* argv[])
 {
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   //Force some cleanup at exit,
   //to help valgrind to detect memory leaks:
   atexit(__libc_freeres);
-#else
+#elif defined(G_OS_WIN32)
   WSADATA data;
   int errcode = WSAStartup(MAKEWORD(2, 0), &data);
   if(errcode != 0)
