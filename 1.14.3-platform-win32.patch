--- origsrc/glom-1.14.3/configure.ac	2010-06-19 08:30:35.000000000 -0500
+++ src/glom-1.14.3/configure.ac	2010-06-30 23:54:31.838154700 -0500
@@ -70,7 +70,11 @@ AM_GLIB_GNU_GETTEXT
 AC_DEFINE([GETTEXT_PACKAGE], [PACKAGE_TARNAME], [Define to the gettext package name.])
 
 AC_MSG_CHECKING([whether to enable Windows specific options])
-AS_CASE([$host_os], [mingw*], [glom_host_win32=yes], [glom_host_win32=no])
+glom_host_cygwin=no
+glom_host_win32=no
+AS_CASE([$host_os], [mingw*], [glom_host_win32=yes],
+                    [cygwin*], [glom_host_cygwin=yes],
+                    [])
 AC_MSG_RESULT([$glom_host_win32])
 
 AS_IF([test "x$glom_host_win32" = xyes],
@@ -148,7 +152,7 @@ AC_ARG_ENABLE([maemo-launcher],
 # libgda >= 4.1.2 is also OK, but not 4.1.<2.
 REQUIRED_LIBGLOM_LIBS='gthread-2.0 giomm-2.4 libxml++-2.6 >= 2.23.1 pygda-4.0 >= 2.25.3 pygobject-2.0 >= 2.6.0 libgdamm-4.0 >= 3.99.18 libgda-4.0 >= 4.0.4 libgda-postgres-4.0'
 
-AS_IF([test "x$glom_host_win32" != xyes],
+AS_IF([test "x$glom_host_win32" != xyes && test "x$glom_host_cygwin" != xyes],
       [REQUIRED_LIBGLOM_LIBS="$REQUIRED_LIBGLOM_LIBS libepc-1.0 >= 0.3.1"])
 
 # Libraries used by Glom:
--- origsrc/glom-1.14.3/glom/application.cc	2010-06-19 07:57:42.000000000 -0500
+++ src/glom-1.14.3/glom/application.cc	2010-06-30 23:56:05.650520400 -0500
@@ -48,10 +48,10 @@
 #include <hildon-fmmm.h>
 #endif // GLOM_ENABLE_MAEMO
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 #include <libepc/consumer.h>
 #include <libsoup/soup-status.h>
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 #include <gtk/gtk.h>
 
@@ -99,7 +99,7 @@ Application::Application(BaseObjectType*
   add_mime_type("application/x-glom"); //TODO: make this actually work - we need to register it properly.
 
 #ifndef GLOM_ENABLE_CLIENT_ONLY
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   //Install UI hooks for this:
   ConnectionPool* connection_pool = ConnectionPool::get_instance();
   if(!connection_pool)
@@ -698,7 +698,7 @@ void Application::ui_warning_load_failed
 }
 
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 void Application::open_browsed_document(const EpcServiceInfo* server, const Glib::ustring& service_name)
 {
   gsize length = 0;
@@ -825,7 +825,7 @@ void Application::open_browsed_document(
     }
   }
 }
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 #ifndef GLOM_ENABLE_CLIENT_ONLY
 //Copied from bakery:
@@ -1412,7 +1412,7 @@ bool Application::offer_new_or_existing(
       case Dialog_ExistingOrNew::OPEN_URI:
         open_document(dialog->get_uri());
         break;
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       case Dialog_ExistingOrNew::OPEN_REMOTE:
         open_browsed_document(dialog->get_service_info(), dialog->get_service_name());
         break;
--- origsrc/glom-1.14.3/glom/application.h	2010-06-19 07:57:42.000000000 -0500
+++ src/glom-1.14.3/glom/application.h	2010-06-30 23:56:29.786900900 -0500
@@ -186,13 +186,13 @@ private:
   void on_connection_avahi_done();
 #endif // !GLOM_ENABLE_CLIENT_ONLY
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   /** Offer a file chooser dialog, with a Browse Network button.
    * @param browsed This will be set to true if the user chose a networked glom instance to open.
    * @browsed_server This will be filled with the server details if browsed was set to true.
    */
   Glib::ustring ui_file_select_open_with_browse(bool& browsed, EpcServiceInfo*& browsed_server, Glib::ustring& browsed_service_name, const Glib::ustring& starting_folder_uri = Glib::ustring());
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   virtual void document_history_add(const Glib::ustring& file_uri); //overridden.
 
@@ -200,9 +200,9 @@ private:
 
   void on_connection_close_progress();
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   void open_browsed_document(const EpcServiceInfo* server, const Glib::ustring& service_name);
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   static Glib::ustring get_file_uri_without_extension(const Glib::ustring& uri);
 
--- origsrc/glom-1.14.3/glom/dialog_existing_or_new.cc	2010-06-19 07:50:50.000000000 -0500
+++ src/glom-1.14.3/glom/dialog_existing_or_new.cc	2010-06-30 23:58:45.487662600 -0500
@@ -36,7 +36,8 @@
 
 #ifdef G_OS_WIN32
 # include <glib/gwin32.h>
-#else
+#endif
+#ifndef G_PLATFORM_WIN32
 # include <libepc/service-type.h>
 #endif
 
@@ -133,7 +134,7 @@ Dialog_ExistingOrNew::Dialog_ExistingOrN
   m_iter_existing_other = m_existing_model->append();
   (*m_iter_existing_other)[m_existing_columns.m_col_title] = _("Select File");
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   m_iter_existing_network = m_existing_model->append();
   (*m_iter_existing_network)[m_existing_columns.m_col_title] = _("Local Network");
 #endif
@@ -178,7 +179,7 @@ Dialog_ExistingOrNew::Dialog_ExistingOrN
 
 
   // Browse local network
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   gchar* service_type = epc_service_type_new(EPC_PROTOCOL_HTTPS, "glom");
   m_service_monitor = epc_service_monitor_new_for_types(0, service_type, (void*)0);
   g_signal_connect(m_service_monitor, "service-found", G_CALLBACK(on_service_found_static), this);
@@ -204,7 +205,7 @@ Dialog_ExistingOrNew::Dialog_ExistingOrN
   if(children.begin() == children.end())
     m_iter_existing_recent_dummy = create_dummy_item_existing(m_iter_existing_recent, _(RECENT_DUMMY_TEXT));
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   // Will be removed when items are added:
   m_iter_existing_network_dummy = create_dummy_item_existing(m_iter_existing_network, _(NETWORK_DUMMY_TEXT));
 #endif
@@ -213,7 +214,7 @@ Dialog_ExistingOrNew::Dialog_ExistingOrN
   // Expand recently used files and the networked files,
   // because the contents help to explain what this is: 
   m_existing_view->expand_row(m_existing_model->get_path(m_iter_existing_recent), false);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   m_existing_view->expand_row(m_existing_model->get_path(m_iter_existing_network), false);
 #endif
 
@@ -292,7 +293,7 @@ bool Dialog_ExistingOrNew::list_examples
 
 Dialog_ExistingOrNew::~Dialog_ExistingOrNew()
 {
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   if(m_service_monitor)
   {
     g_object_unref(m_service_monitor);
@@ -313,7 +314,7 @@ Dialog_ExistingOrNew::~Dialog_ExistingOr
 bool Dialog_ExistingOrNew::on_existing_select_func(const Glib::RefPtr<Gtk::TreeModel>& model, const Gtk::TreeModel::Path& path, bool /* path_currently_selected */)
 {
   Gtk::TreeModel::iterator iter = model->get_iter(path);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   if(iter == m_iter_existing_network)
     return false; /* Do not allow parent nodes to be selected. */
 #endif
@@ -344,7 +345,7 @@ Dialog_ExistingOrNew::Action Dialog_Exis
     iter = m_existing_view->get_selection()->get_selected();
     if(m_existing_model->is_ancestor(m_iter_existing_recent, iter))
       return OPEN_URI;
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     if(m_existing_model->is_ancestor(m_iter_existing_network, iter))
       return OPEN_REMOTE;
 #endif
@@ -412,7 +413,7 @@ Glib::ustring Dialog_ExistingOrNew::get_
   return Glib::ustring();
 }
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 EpcServiceInfo* Dialog_ExistingOrNew::get_service_info() const
 {
   Gtk::TreeModel::iterator iter;
@@ -477,7 +478,7 @@ void Dialog_ExistingOrNew::existing_icon
 
   if(iter == m_iter_existing_recent)
     pixbuf_renderer->property_stock_id() = Gtk::Stock::INDEX.id; // TODO: More meaningful icon?
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   else if(iter == m_iter_existing_network)
     pixbuf_renderer->property_stock_id() = Gtk::Stock::NETWORK.id;
 #endif
@@ -485,7 +486,7 @@ void Dialog_ExistingOrNew::existing_icon
     pixbuf_renderer->property_stock_id() = Gtk::Stock::OPEN.id;
   else if(m_iter_existing_recent_dummy.get() && iter == *m_iter_existing_recent_dummy)
     pixbuf_renderer->property_stock_id() = ""; // TODO: Use Stock::STOP instead?
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   else if(m_iter_existing_network_dummy.get() && iter == *m_iter_existing_network_dummy)
     pixbuf_renderer->property_stock_id() = ""; // TODO: Use Stock::STOP instead?
 #endif
@@ -498,7 +499,7 @@ void Dialog_ExistingOrNew::existing_icon
 
   if(iter == m_iter_existing_recent)
     pixbuf_renderer->set_property("stock-id", Gtk::StockID(Gtk::Stock::INDEX));
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   else if(iter == m_iter_existing_network)
     pixbuf_renderer->set_property("stock-id", Gtk::StockID(Gtk::Stock::NETWORK));
 #endif
@@ -506,7 +507,7 @@ void Dialog_ExistingOrNew::existing_icon
     pixbuf_renderer->set_property("stock-id", Gtk::StockID(Gtk::Stock::OPEN));
   else if(m_iter_existing_recent_dummy.get() && iter == *m_iter_existing_recent_dummy)
     pixbuf_renderer->set_property("stock-id", std::string()); // TODO: Use Stock::STOP instead?
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   else if(m_iter_existing_network_dummy.get() && iter == *m_iter_existing_network_dummy)
     pixbuf_renderer->set_property("stock-id", std::string()); // TODO: Use Stock::STOP instead?
 #endif
@@ -520,7 +521,7 @@ void Dialog_ExistingOrNew::existing_icon
       //pixbuf_renderer->property_pixbuf() = (*info)->get_icon(Gtk::ICON_SIZE_BUTTON);
       pixbuf_renderer->set_property("icon-name", Glib::ustring("glom"));
     }
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     else if(m_existing_model->is_ancestor(m_iter_existing_network, iter))
     {
       //pixbuf_renderer->property_stock_id() = Gtk::Stock::CONNECT.id;
@@ -553,7 +554,7 @@ void Dialog_ExistingOrNew::existing_titl
   text_renderer->property_foreground_set() = false;
   
   // Use grey if parent item has no children:
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   if( (iter == m_iter_existing_network && m_iter_existing_network_dummy.get()) ||
       (iter == m_iter_existing_recent && m_iter_existing_recent_dummy.get()))
 #else
@@ -568,7 +569,7 @@ void Dialog_ExistingOrNew::existing_titl
   // Default: Use default color
   text_renderer->set_property("foreground-set", false);
   // Use grey if parent item has no children
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   if( (iter == m_iter_existing_network && m_iter_existing_network_dummy.get()) ||
       (iter == m_iter_existing_recent && m_iter_existing_recent_dummy.get()))
 #else
@@ -710,12 +711,12 @@ void Dialog_ExistingOrNew::update_ui_sen
     {
       Gtk::TreeModel::iterator sel = m_existing_view->get_selection()->get_selected();
       sensitivity = (sel != m_iter_existing_recent);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       sensitivity = sensitivity && (sel != m_iter_existing_network);
 #endif
 
       sensitivity = sensitivity && (!m_iter_existing_recent_dummy.get() || sel != *m_iter_existing_recent_dummy);
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       sensitivity = sensitivity && (!m_iter_existing_network_dummy.get() || sel != *m_iter_existing_network_dummy);
 #endif
     }
@@ -867,7 +868,7 @@ void Dialog_ExistingOrNew::on_stream_rea
 }
 #endif /* !GLOM_ENABLE_CLIENT_ONLY */
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 void Dialog_ExistingOrNew::on_service_found_static(EpcServiceMonitor* /* monitor */, gchar* name, EpcServiceInfo* info, gpointer user_data)
 {
   static_cast<Dialog_ExistingOrNew*>(user_data)->on_service_found(name, info);
@@ -919,7 +920,7 @@ void Dialog_ExistingOrNew::on_service_re
     }
   }
 }
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 void Dialog_ExistingOrNew::on_existing_row_activated(const Gtk::TreeModel::Path& /* path */, Gtk::TreeViewColumn* /* column */)
 {
--- origsrc/glom-1.14.3/glom/dialog_existing_or_new.h	2010-05-12 14:38:54.000000000 -0500
+++ src/glom-1.14.3/glom/dialog_existing_or_new.h	2010-06-30 23:59:28.248108300 -0500
@@ -35,7 +35,7 @@
 #include <gtkmm/notebook.h>
 #include <gtkmm/builder.h>
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 # include <libepc/service-monitor.h>
 #endif
 
@@ -62,7 +62,7 @@ public:
 
   Action get_action() const;
   Glib::ustring get_uri() const; // Only when get_action is NEW_FROM_TEMPLATE or OPEN_URI
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   EpcServiceInfo* get_service_info() const; // Only when get_action is OPEN_REMOTE
   Glib::ustring get_service_name() const; // Only when get_action is OPEN_REMOTE
 #endif
@@ -101,7 +101,7 @@ private:
   void on_stream_read(const Glib::RefPtr<Gio::AsyncResult>& res);
 #endif /* !GLOM_ENABLE_CLIENT_ONLY */
     
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   static void on_service_found_static(EpcServiceMonitor* monitor, gchar* name, EpcServiceInfo* info, gpointer user_data);
   static void on_service_removed_static(EpcServiceMonitor* monitor, gchar* name, gchar* type, gpointer user_data);
 
@@ -126,7 +126,7 @@ private:
       add(m_col_title);
       add(m_col_time);
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
       add(m_col_service_name);
       add(m_col_service_info);
 #endif
@@ -137,7 +137,7 @@ private:
     Gtk::TreeModelColumn<Glib::ustring> m_col_title;
     Gtk::TreeModelColumn<std::time_t> m_col_time; // Sort criteria
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     // For service discovery:
     Gtk::TreeModelColumn<Glib::ustring> m_col_service_name;
     Gtk::TreeModelColumn<EpcServiceInfo*> m_col_service_info;
@@ -184,13 +184,13 @@ private:
 
   //Iterators to the parent nodes:
   Gtk::TreeModel::iterator m_iter_existing_recent;
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   Gtk::TreeModel::iterator m_iter_existing_network;
 #endif
   Gtk::TreeModel::iterator m_iter_existing_other;
  
   // Dummy children to indicate that a parent item has no (real) children
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   std::auto_ptr<Gtk::TreeModel::iterator> m_iter_existing_network_dummy;
 #endif
   std::auto_ptr<Gtk::TreeModel::iterator> m_iter_existing_recent_dummy;
@@ -206,7 +206,7 @@ private:
   std::auto_ptr<buffer> m_current_buffer;
 #endif /* !GLOM_ENABLE_CLIENT_ONLY */
     
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   EpcServiceMonitor* m_service_monitor;
 #endif
 
--- origsrc/glom-1.14.3/glom/frame_glom.cc	2010-06-19 07:50:51.000000000 -0500
+++ src/glom-1.14.3/glom/frame_glom.cc	2010-07-01 00:00:40.612247300 -0500
@@ -1185,7 +1185,7 @@ void Frame_Glom::on_menu_Mode_Find()
     m_Notebook_Find.set_current_view(list_or_details);
   }
 
-  #ifdef GLOM_ENABLE_CLIENT_ONLY
+  #ifdef GLOM_ENABLE_MAEMO
   Gtk::Window* parent = get_app_window();
   g_assert(parent);
   if(parent)
--- origsrc/glom-1.14.3/glom/libglom/connectionpool.cc	2010-06-19 07:26:37.000000000 -0500
+++ src/glom-1.14.3/glom/libglom/connectionpool.cc	2010-07-01 00:01:55.598536300 -0500
@@ -31,7 +31,8 @@
 
 #ifdef G_OS_WIN32
 # include <windows.h>
-#else
+#endif
+#ifndef G_PLATFORM_WIN32
 # include <libepc/shell.h> //For epc_shell_set_progress_hooks().
 # include <libepc/publisher.h>
 #endif
@@ -41,7 +42,7 @@
 #include <glibmm/i18n.h>
 
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 static EpcProtocol publish_protocol = EPC_PROTOCOL_HTTPS;
 #endif
 
@@ -356,7 +357,7 @@ sharedptr<SharedConnection> ConnectionPo
         if(!m_pFieldTypes)
           m_pFieldTypes = new FieldTypes(m_refGdaConnection);
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
         //Let other clients discover this server via avahi:
         //TODO: Only advertize if we are the first to open the document,
         //to avoid duplicates.
@@ -365,7 +366,7 @@ sharedptr<SharedConnection> ConnectionPo
         Document* document = get_document();
         if(document && document->get_network_shared())
           avahi_start_publishing(); //Stopped in the signal_finished handler.
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 #ifdef GLIBMM_EXCEPTIONS_ENABLED
         return connect(); //Call this method recursively. This time m_refGdaConnection exists.
@@ -489,7 +490,7 @@ void ConnectionPool::on_sharedconnection
 
     m_refGdaConnection.reset();
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
     //TODO: this should only even be started if we are the first to open the .glom file:
     avahi_stop_publishing();
 #endif
@@ -576,10 +577,10 @@ bool ConnectionPool::startup(const SlotP
   if(!m_backend->startup(slot_progress, network_shared))
     return false;
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   //Let clients discover this server via avahi:
   //avahi_start_publishing();
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   //If we crash while running (unlikely, hopefully), then try to cleanup.
   //Comment this out if you want to see the backtrace in a debugger.
@@ -608,10 +609,10 @@ bool ConnectionPool::cleanup(const SlotP
   invalidate_connection();
 
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   /* Stop advertising the self-hosting database server via avahi: */
   //avahi_stop_publishing();
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   //We don't need the segfault handler anymore:
   signal(SIGSEGV, previous_sig_handler);
@@ -779,7 +780,7 @@ Document* ConnectionPool::get_document()
   return m_slot_get_document();
 }
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 //static
 EpcContents* ConnectionPool::on_publisher_document_requested(EpcPublisher* /* publisher */, const gchar* /* key */, gpointer user_data)
 {
@@ -935,13 +936,13 @@ void ConnectionPool::avahi_stop_publishi
   std::cout << "debug: ConnectionPool::avahi_stop_publishing" << std::endl;
 #endif
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   epc_publisher_quit(m_epc_publisher);
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
   g_object_unref(m_epc_publisher);
   m_epc_publisher = 0;
 }
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 void ConnectionPool::set_get_document_func(const SlotGetDocument& slot)
 {
--- origsrc/glom-1.14.3/glom/libglom/connectionpool.h	2010-06-19 07:26:37.000000000 -0500
+++ src/glom-1.14.3/glom/libglom/connectionpool.h	2010-07-01 00:02:50.791693200 -0500
@@ -109,7 +109,7 @@ public:
   
   typedef sigc::slot<void> type_void_slot;
   
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   /** Set callbacks that will be called to show UI while starting to advertise 
    * on the network via Avahi.
    *
@@ -246,14 +246,14 @@ public:
   typedef sigc::slot<Document*> SlotGetDocument; 
   void set_get_document_func(const SlotGetDocument& slot);
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   static EpcContents* on_publisher_document_requested (EpcPublisher* publisher, const gchar* key, gpointer user_data);
   static gboolean on_publisher_document_authentication(EpcAuthContext* context, const gchar* user_name, gpointer user_data);
 
   static void on_epc_progress_begin(const gchar *title, gpointer user_data);
   static void on_epc_progress_update(gdouble progress, const gchar* message, gpointer user_data);
   static void on_epc_progress_end(gpointer user_data);
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
   //Show the gda error in a dialog.
   static bool handle_error_cerr_only();
@@ -273,12 +273,12 @@ private:
 
   Document* get_document();
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   /** Advertize self-hosting via avahi:
    */
   void avahi_start_publishing();
   void avahi_stop_publishing();
-#endif // !G_OS_WIN32
+#endif // !G_PLATFORM_WIN32
 
 private:
 
--- origsrc/glom-1.14.3/glom/main.cc	2010-06-19 07:26:37.000000000 -0500
+++ src/glom-1.14.3/glom/main.cc	2010-07-01 00:05:08.196552300 -0500
@@ -363,18 +363,19 @@ bool check_pygda_is_available_with_warni
 
 } //namespace Glom
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 extern "C" void __libc_freeres(void);
 #endif
 
 int 
 main(int argc, char* argv[])
 {
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   //Force some cleanup at exit,
   //to help valgrind to detect memory leaks:
   atexit(__libc_freeres);
-#else
+#endif
+#ifdef G_OS_WIN32
   WSADATA data;
   int errcode = WSAStartup(MAKEWORD(2, 0), &data);
   if(errcode != 0)
--- origsrc/glom-1.14.3/tests/test_python_module.cc	2010-02-01 09:01:04.000000000 -0600
+++ src/glom-1.14.3/tests/test_python_module.cc	2010-07-01 00:05:42.509514900 -0500
@@ -5,7 +5,7 @@
 #include "config.h"
 #include "glom/python_embed/glom_python.h"
 
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
 extern "C" void __libc_freeres(void);
 #endif
 
@@ -41,7 +41,7 @@ bool gda_python_module_is_available()
 
 int main ()
 {
-#ifndef G_OS_WIN32
+#ifndef G_PLATFORM_WIN32
   atexit(__libc_freeres);
 #endif
   Glom::libglom_init();  // Calls PyInitialize()
